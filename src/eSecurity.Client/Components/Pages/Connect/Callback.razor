@page "/connect/callback"

@using eSecurity.Client.Common.JS.Fetch
@using eSecurity.Client.Security.Authentication.OpenIdConnect
@using eSecurity.Client.Security.Authentication.OpenIdConnect.Token
@using eSecurity.Core.Common.DTOs
@using eSystem.Core.Security.Authentication.OpenIdConnect.Client
@using eSystem.Core.Security.Authorization.OAuth.Constants
@using eSystem.Core.Security.Authorization.OAuth.Token.AuthorizationCode
@using Microsoft.AspNetCore.Authentication
@using TokenTypes = eSecurity.Client.Security.Authentication.OpenIdConnect.Token.AuthTokenTypes

@inherits PageBase

@layout AuthenticationLayout

@inject IConnectService ConnectService
@inject IOptions<ClientOptions> ClientOptions
@inject IFetchClient FetchClient
@inject ITokenValidator TokenValidator

@if (!string.IsNullOrEmpty(Code))
{
    <Title Text="Authorizing to eSystem Account"></Title>
}
else
{
    <Title Text="Failed authorization"></Title>
}

@if (!string.IsNullOrEmpty(Error) && !string.IsNullOrEmpty(ErrorDescription))
{
    <MudGrid Justify="Justify.Center">
        <MudItem xs="4" Style="margin-top: 150px">
            <MudPaper Outlined="true" Class="pa-5">
                <MudStack Spacing="3">
                    <MudStack AlignItems="AlignItems.Center" Justify="Justify.Center">
                        <MudIcon
                            Color="Color.Error"
                            Size="Size.Large"
                            Style="font-size: 5rem"
                            Icon="@Icons.Material.Outlined.Cancel"/>
                    </MudStack>
                    <MudTextM3 Typo="TypoM3.Headline" Size="Size.Small" Align="Align.Center">
                        Authorization Error
                    </MudTextM3>
                    <MudStack Spacing="1">
                        <MudTextM3 Typo="TypoM3.Body" Size="Size.Large">
                            <strong>Error:</strong> @Error
                        </MudTextM3>
                        <MudTextM3 Typo="TypoM3.Body" Size="Size.Large">
                            <strong>Description:</strong> @ErrorDescription
                        </MudTextM3>
                    </MudStack>
                </MudStack>
            </MudPaper>
        </MudItem>
    </MudGrid>
}

@code {

    [SupplyParameterFromQuery(Name = "code")]
    public string Code { get; set; } = string.Empty;

    [SupplyParameterFromQuery(Name = "state")]
    public string State { get; set; } = string.Empty;
    
    [SupplyParameterFromQuery(Name = "return_url")]
    public string ReturnUrl { get; set; } = string.Empty;

    [SupplyParameterFromQuery(Name = "error")]
    public string? Error { get; set; } = string.Empty;

    [SupplyParameterFromQuery(Name = "error_description")]
    public string? ErrorDescription { get; set; } = string.Empty;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && string.IsNullOrEmpty(Error) && string.IsNullOrEmpty(ErrorDescription))
        {
            var options = ClientOptions.Value;
            var request = new AuthorizationCodeRequest
            {
                ClientId = options.ClientId,
                ClientSecret = options.ClientSecret,
                RedirectUri = options.CallbackUri,
                GrantType = GrantTypes.AuthorizationCode,
                Code = Code,
            };

            var result = await ConnectService.TokenAsync(request);
            if (result.Succeeded && result.TryGetValue<AuthorizationCodeResponse>(out var response) && response is not null)
            {
                var tokenResult = await TokenValidator.ValidateAsync(response.IdToken!);
                if (!tokenResult.Succeeded)
                {
                    var error = tokenResult.GetError();
                    Snackbar.Add(error.Description, Severity.Error);
                }
                
                var tokenIdentity = new SignIdentity
                {
                    Claims = tokenResult.Get<List<ClaimValue>>(),
                    Tokens =
                    [
                        new AuthenticationToken { Name = TokenTypes.AccessToken, Value = response.AccessToken! },
                        new AuthenticationToken { Name = TokenTypes.IdToken, Value = response.IdToken! },
                        new AuthenticationToken { Name = TokenTypes.RefreshToken, Value = response.RefreshToken! },
                    ]
                };

                var fetchOptions = new FetchOptions
                {
                    Url = $"{NavigationManager.BaseUri}api/authentication/sign-in",
                    Method = HttpMethod.Post,
                    Body = tokenIdentity
                };

                var signResult = await FetchClient.FetchAsync(fetchOptions);
                if (signResult.Succeeded)
                {
                    var url = string.IsNullOrEmpty(ReturnUrl) ? Links.Common.Profile : ReturnUrl;
                    NavigationManager.NavigateTo(url, true);
                }
            }
        }
    }

}